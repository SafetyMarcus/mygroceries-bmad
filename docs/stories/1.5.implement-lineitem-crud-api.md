# Story 1.5: Implement Order and LineItem CRUD APIs

## Status
Ready for Dev

## Story
**As a** developer,
**I want** to create API endpoints for managing `Order` and `LineItem` data,
**so that** orders and their associated line items can be managed in the system.

## Acceptance Criteria
### Order CRUD API
1. An `Order` data class is defined in the `shared` module with the following fields:
   - `id`: UUID (primary key)
   - `orderDate`: Instant
   - `totalCost`: BigDecimal
   - `lineItems`: List<LineItem> (transient, for API responses)

2. The Ktor server exposes RESTful endpoints at an `/orders` path.

3. The following endpoints are implemented for Orders:
   * `POST /orders`: Creates a new order.
   * `GET /orders`: Retrieves all orders with pagination.
   * `GET /orders/{id}`: Retrieves a single order by its ID, including its line items.
   * `PUT /orders/{id}`: Updates an existing order.
   * `DELETE /orders/{id}`: Deletes an order and its associated line items.

### LineItem CRUD API
4. A `LineItem` data class is defined in the `shared` module with the following fields:
   - `id`: UUID (primary key)
   - `orderId`: UUID (foreign key to Order)
   - `productId`: UUID (foreign key to Product)
   - `quantity`: Double
   - `cost`: BigDecimal
   - `product`: Product? (transient, for API responses)

5. The Ktor server exposes RESTful endpoints at `/orders/{orderId}/lineitems` and `/lineitems` paths.

6. The following endpoints are implemented for LineItems:
   * `POST /orders/{orderId}/lineitems`: Creates a new line item for a specific order.
   * `GET /orders/{orderId}/lineitems`: Retrieves all line items for a specific order.
   * `GET /lineitems/{id}`: Retrieves a single line item by its ID.
   * `PUT /lineitems/{id}`: Updates an existing line item.
   * `DELETE /lineitems/{id}`: Deletes a line item.

### Validation and Business Rules
7. Server-side validation is implemented for Orders:
   - `orderDate` must be a valid timestamp
   - `totalCost` must be a non-negative number
   - When creating/updating an order, the total cost must match the sum of its line items

8. Server-side validation is implemented for LineItems:
   - All IDs must be handled as UUIDs
   - The `orderId` must correspond to an existing order in the database
   - The `productId` must correspond to an existing product in the database
   - `quantity` must be a positive number
   - `cost` must be a non-negative number
   - When a line item is created/updated, the parent order's total cost must be recalculated

9. The functionality is covered by automated tests for both Order and LineItem APIs.

## Tasks / Subtasks
### Order Implementation
- [x] Define `Order` data class in `shared` module
    - [x] Create `Order.kt` in `shared/src/commonMain/kotlin/com/example/mygroceries/model/`
    - [x] Implement fields with appropriate data types and serialization

- [x] Implement Order repository/DAO for database operations
    - [x] Create `OrderRepository.kt` in `server/src/main/kotlin/com/example/mygroceries/db/`
    - [x] Implement `create`, `readAll`, `readById`, `update`, `delete` functions using Exposed
    - [x] Set up proper foreign key relationships with `line_items` table

- [x] Implement Order service layer
    - [x] Create `OrderService.kt` in `server/src/main/kotlin/com/example/mygroceries/service/`
    - [x] Inject `OrderRepository` and `LineItemRepository`

- [x] Implement Order API routes
    - [x] Create `OrderRoutes.kt` in `server/src/main/kotlin/com/example/mygroceries/routes/`
    - [x] Define all required endpoints with proper request/response handling
    - [x] Implement business logic for CRUD operations, including validation

### LineItem Implementation
- [x] Define `LineItem` data class in `shared` module
    - [x] Create `LineItem.kt` in `shared/src/commonMain/kotlin/com/example/mygroceries/model/`
    - [x] Implement fields with appropriate data types and serialization

- [x] Implement LineItem repository/DAO for database operations
    - [x] Create `LineItemRepository.kt` in `server/src/main/kotlin/com/example/mygroceries/db/`
    - [x] Implement `create`, `readAll`, `readById`, `update`, `delete` functions using Exposed
    - [x] Set up proper foreign key relationships with `orders` and `products` tables
    - [x] Implement methods to find line items by order ID

- [x] Implement LineItem service layer
    - [x] Create `LineItemService.kt` in `server/src/main/kotlin/com/example/mygroceries/service/`
    - [x] Inject `LineItemRepository`, `OrderRepository`, and `ProductRepository`

- [x] Implement LineItem API routes
    - [x] Create `LineItemRoutes.kt` in `server/src/main/kotlin/com/example/mygroceries/routes/`
    - [x] Define all required endpoints with proper request/response handling
    - [x] Implement business logic for CRUD operations, including validation
    - [x] Implement nested routes under `/orders/{orderId}/lineitems`

### Total Cost Implementation
- [ ] Implement computed field for `totalCost` in `Order` data class

### Testing
- [x] Add unit tests for `OrderService`
    - [x] Test validation logic

- [x] Add integration tests for Order API endpoints
    - [x] Test successful CRUD operations
    - [x] Test validation error cases
    - [x] Test order total cost calculation

- [x] Add unit tests for `LineItemService`
    - [x] Test validation logic

- [x] Add integration tests for LineItem API endpoints
    - [x] Test successful CRUD operations
    - [x] Test validation error cases

- [ ] Test total cost calculation
- [ ] Update API documentation

## Dev Notes

### Previous Story Insights
- Database schema includes `orders` and `line_items` tables with proper relationships
- Product and Category CRUD APIs are implemented and can be used for validation
- Project follows a clean architecture with clear separation of concerns

### Database Schema
```sql
-- orders table
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    order_date TIMESTAMPTZ NOT NULL,
);

-- line_items table
CREATE TABLE line_items (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(id),
    quantity DOUBLE PRECISION NOT NULL,
    cost NUMERIC(10, 2) NOT NULL
);

-- Indexes
CREATE INDEX idx_line_items_order_id ON line_items(order_id);
CREATE INDEX idx_line_items_product_id ON line_items(product_id);
```

### Data Models
#### Order.kt
```kotlin
package com.safetymarcus.mygroceries.model

data class Order(
    val id: Uuid? = null,
    val orderDate: Instant,
)

data class NewOrder(
    val orderDate: Instant = Clock.System.now(),
    val lineItems: List<NewLineItem> = emptyList()
)
```

#### LineItem.kt
```kotlin
package com.safetymarcus.mygroceries.model

data class LineItem(
    val id: Uuid? = null,
    val orderId: Uuid,
    val productId: Uuid,
    val quantity: Double,
    val cost: Double,
    val product: Product? = null
)

data class NewLineItem(
    val productId: Uuid,
    val quantity: Double,
    val cost: Double
)
```

### Repository Layer
#### OrderRepository.kt
```kotlin
package com.safetymarcus.mygroceries.db

object Orders : Table() {
    val id = uuid("id")
    val orderDate = timestamp("order_date")
    val totalCost = decimal("total_cost", 10, 2)
    override val primaryKey = PrimaryKey(id)
}

object OrderRepository {
    // CRUD operations following the same pattern as ProductRepository
}
```

#### LineItemRepository.kt
```kotlin
package com.safetymarcus.mygroceries.db

object LineItems : Table() {
    val id = uuid("id")
    val orderId = reference("order_id", Orders.id, onDelete = ReferenceOption.CASCADE)
    val productId = reference("product_id", Products.id)
    val quantity = double("quantity")
    val cost = decimal("cost", 10, 2)
    override val primaryKey = PrimaryKey(id)
}

object LineItemRepository {
    // CRUD operations following the same pattern as other repositories
}
```

### Service Layer
#### OrderService.kt
```kotlin
package com.safetymarcus.mygroceries.service

class OrderService(
    private val orderRepository: OrderRepository = OrderRepository,
    private val lineItemRepository: LineItemRepository = LineItemRepository,
    private val productService: ProductService = ProductService()
) {
    // CRUD operations with transaction management
    // Calculate order total from line items
    // Handle order-lineitem relationships
}
```

#### LineItemService.kt
```kotlin
package com.safetymarcus.mygroceries.service

class LineItemService(
    private val lineItemRepository: LineItemRepository = LineItemRepository,
    private val orderService: OrderService = OrderService(),
    private val productService: ProductService = ProductService()
) {
    // CRUD operations with validation
    // Update parent order total when line items change
}
```

### Route Layer
#### OrderRoutes.kt
```kotlin
package com.safetymarcus.mygroceries.routes

fun Route.orderRoutes(orderService: OrderService) {
    route("/orders") {
        // Standard CRUD endpoints following the same pattern as productRoutes
    }
}
```

#### LineItemRoutes.kt
```kotlin
package com.safetymarcus.mygroceries.routes

fun Route.lineItemRoutes(
    lineItemService: LineItemService,
    orderService: OrderService,
    productService: ProductService
) {
    // Nested under /orders/{orderId}/lineitems
    // Direct access via /lineitems/{id}
}
```

### Application Setup
```kotlin
// In Application.kt
fun Application.module() {
    // ... existing setup ...
    
    val orderService = OrderService()
    val lineItemService = LineItemService()
    
    // Add to existing routing
    routing {
        orderRoutes(orderService)
        lineItemRoutes(lineItemService, orderService, productService)
    }
}
```

### Validation
Add validation for the new models:
```kotlin
// In validations.kt
fun NewOrder.validate(): ValidationResult {
    return ValidationResult(
        validate(orderDate > Instant.DISTANT_PAST) { "Order date must be in the future" },
        validate(totalCost >= 0) { "Total cost cannot be negative" },
        validate(lineItems.isNotEmpty()) { "Order must have at least one line item" }
    )
}

fun NewLineItem.validate(): ValidationResult {
    return ValidationResult(
        validate(quantity > 0) { "Quantity must be positive" },
        validate(cost >= 0) { "Cost cannot be negative" }
    )
}
```

- **Testing**:
    - Unit tests for both `OrderService` and `LineItemService`
    - Integration tests for all API endpoints
    - Test data setup using test fixtures
    - Test coverage for:
      - Success and error cases
      - Order total cost calculations
      - Line item validation and updates
      - Cascading deletes and updates

- **Technical Constraints**:
    - Language: Kotlin 1.9.23
    - Core Framework: Kotlin Multiplatform 1.6.10
    - Database: PostgreSQL with Exposed ORM
    - Testing: Kotest with MockK

## Testing
### Order Tests
#### Unit Tests
- Test `OrderService` methods
  - Create order with and without line items
  - Update order details
  - Delete order with and without line items
  - Calculate order total from line items
  - Handle validation errors

#### Integration Tests
- Test Order API endpoints
  - Create/Read/Update/Delete operations
  - Retrieve orders with nested line items
  - Handle validation errors
  - Pagination for order lists

### LineItem Tests
#### Unit Tests
- Test `LineItemService` methods
  - Create/Read/Update/Delete line items
  - Update parent order totals on changes
  - Handle validation errors
  - Check product existence

#### Integration Tests
- Test LineItem API endpoints
  - Create/Read/Update/Delete operations
  - Nested routes under orders
  - Direct access via `/lineitems`
  - Update parent order totals
  - Handle validation errors

### Cross-Feature Tests
- Create order with line items in a single transaction
- Update order with multiple line items
- Delete order and verify cascading deletes
- Concurrency tests for order updates

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-18 | 1.0 | Initial draft | Bob (SM) |
